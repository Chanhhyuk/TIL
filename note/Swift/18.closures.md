# Closures(클로저)
- 이름이 없는(익명) 함수
- 클로저는 아웃풋(return타입) 생략가능 (컴파일러가 인풋으로 추론함)
```swift
func add(a: Int, b: Int) -> Int {   // 함수
    let result = a + b
    return result
}

{ (a: Int, b: Int) in       // 구분해주기 위해서 in을 사용함
    let result = a + b
    return result
}

let _ (Int, Int) -> Int =   // 다른 요소로 인해 타입이 이미 결정되었을때만 타입생략가능
{ (a,b) in                  
    let result = a + b
    return result
}
```
**함수는 타입이자 일급객체로 취급 (프로토콜도 타입이자 일급객체)**
1) 함수를 변수에 할당할 수 있음
```swift
let apple = { print('redApple') }
apple()
```
2) 함수를 호출할때, 함수를 파라미터로 전달할 수 있음
3) 함수에서 함수를 반환할 수 있음


## 클로저 문법 최적화
- 간결한 코드 작성을 위해 축약된 형태의 문법을 제공
- 파라미터와 리턴타입을 Type Inference(타입 추론)
- 싱글 익스프레션인 경우(한줄), 리턴을 안 적어도 됨(Implicit Return)
- 아규먼트 이름을 축약(Shorthand Arguments) => $0, $1
- Trailling Closure문법: 함수의 마지막 전달 인자(argument)로 클로저 전달되는 경우ㅡ 소괄호 생략 가능


- 함수를 실행할때 파라미터로 전달하는 함수: Callback 함수

```swift
// 본래의 함수가 정의되어 있고
func startEnd(closure: () -> () ) {     // closure: () -> (): Callback 함수
    print("Start!")
    closure()
}

// 파라미터로 쓰일 함수가 정의되어 있다.
func printEndFunction() {       // 함수를 정의
    print("End")
}

let printEnd = { () -> () in    // 클로저를 정의
    print("End")
}

startEnd(closure: printEndFunction)
startEnd(closure: printEnd)

startEnd(closure: {              // 정의를 하면서 값을 전달
    print("End. bye!")
})
```
