# Generics(제네릭)

```swift
var n1 = 10
var n2 = 20
```
- 두개를 바꾸기 위해서는 inout을 사용하고 반드시 &를 사용해야 했다

- 기능은 같은데 타입마다 따로 따로 정의해주어야 한다.
- 단지 타입만 바뀌었을 뿐인데 반복적으로 코드를 구현해야됫음

- 타입을 넣어야 할 곳에 대문자를 임의로 넣는다 ex) T(Type) 관습적으로 T하나만 쓰는게 약속
- 단 함수 옆에다가 <T>로 안에 똑같이 써줘야 한다.
- <> 를 타입파라미터라고 한다.
- <T, A> 처럼 여러개 사용가능 대신 ()안에도 똑같이 사용해야함

- Array<String> 또한 제네릭문법 Array<T>처럼 정의가 내장되어있다.
- 그래서 Array를 사용할 때 String,Int,Double 다 사용 가능했던것
- 애플이 미리구현해 놓은 함수 swap도 제네릭으로 구현되어있음

## 제네릭 정의

```swift
struct GenericMember<T> {
    var members: [T] = []
}

var g = GenericMember(
// 여기까지만 치면 기본생성자도 제공되고, 멤버이니셜라이즈도 제공된다

var g = GenericMember(members:[1,2,3]
// 이렇게 붕어빵을 찍어내면 변수의 타입이 정해진다. 타입이 고정된다 메모리 구조가 결정된다.


extension coor where T == Int {     // 타입이 정수형일때만 구현이 된다.
}

T: Equatable    // Equatable 프로토콜을 채택만 타입만 가능하다. 타입으로써 함수에서 사용가능하다. 
```
- GridPoint 클래스이기 때문에 생성자를 만든것 (init)
- enum에서는 case 하나가 특별한 타입이기 때문에 타입을 정의할 일은 없다
- 즉 특별한경우 연관값을 가진 경우에만 case 뒤에 <T>를 붙여서 사용
- 확장할때 굳이 extension 뒤에 <T> 븥일필요 없이 본체에만 붙여도 사용 가능

- 제네릭 단점 너무 일반적으로 정의해 놓으니까 모든 케이스가 일반적인 정의에 맞춰서 사용할 수 밖에 없다?

## 프로토콜 제네릭
- 프로토콜에서는 제네릭을 사용할 때 연관되었다고 associatedtype을 사용
- 프로토콜을 채택할 경우 프로토콜에 사용에 있는걸 다 채택해줘야 되는데 associatedtype으로 선언된것을 사용할 경우에는 typealias를 사용

- typealias Number = Int  > 내가 Int를 익숙한 Number로 변경하고 싶을 때
- 프로토콜 자체는 타입이 아니다 타입이 아니다? 그러면 뭐라는걸까? 객체?
- Equatable 프로토콜을 채택한 타입만 정의할 수 있다.
